/*
 * Copyright (c) 2015 Keith Cullen.
 * All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <arpa/inet.h>
#include "coap_msg.h"
#include "harness.h"

#undef DEBUG
#define DIM(x) (sizeof(x) / sizeof(x[0]))

static void print_coap_msg(coap_msg_t *msg)
{
#ifdef DEBUG
    coap_msg_op_t *op = NULL;
    unsigned num = 0;
    unsigned len = 0;
    unsigned i = 0;
    unsigned j = 0;
    char *val = NULL;

    printf("ver:         0x%02x\n", msg->ver);
    printf("type:        0x%02x\n", msg->type);
    printf("token_len:   %d\n", msg->token_len);
    printf("code_class:  %d\n", msg->code_class);
    printf("code_detail: %d\n", msg->code_detail);
    printf("msg_id:      0x%04x\n", msg->msg_id);
    printf("token:      ");
    for (i = 0; i < msg->token_len; i++)
    {
        printf(" 0x%02x", (unsigned char)msg->token[i]);
    }
    printf("\n");
    op = coap_msg_op_list_get_first(&msg->op_list);
    while (op != NULL)
    {
        num = coap_msg_op_get_num(op);
        len = coap_msg_op_get_len(op);
        val = coap_msg_op_get_val(op);
        printf("op[%u].num:   %u\n", j, num);
        printf("op[%u].len:   %u\n", j, len);
        printf("op[%u].val:  ", j);
        for (i = 0; i < len; i++)
        {
            printf(" 0x%02x", (unsigned char)val[i]);
        }
        printf("\n");
        op = coap_msg_op_get_next(op);
        j++;
    }
    printf("payload:    ");
    for (i = 0; i < msg->payload_len; i++)
    {
        printf(" 0x%02x", (unsigned char)msg->payload[i]);
    }
    printf("\n");
    printf("payload_len: %d\n", msg->payload_len);
#endif
}

static void print_buf(char *buf, unsigned len)
{
#ifdef DEBUG
    unsigned i = 0;

    printf("buffer:");
    for (i = 0; i < len; i++)
    {
        printf(" 0x%02x", (unsigned char)buf[i]);
    }
    printf("\n");
#endif
}

struct test_op
{
    unsigned num;
    unsigned len;
    char *val;
};

struct test_data
{
    const char *parse_desc;
    const char *format_desc;
    int parse_ret;
    int set_type_ret;
    int set_code_ret;
    int set_msg_id_ret;
    int set_token_ret;
    int *add_op_ret;
    int set_payload_ret;
    int format_ret;
    char *buf;
    unsigned buf_len;
    unsigned ver;
    coap_msg_type_t type;
    unsigned code_class;
    unsigned code_detail;
    unsigned msg_id;
    char *token;
    unsigned token_len;
    struct test_op *ops;
    unsigned num_ops;
    char *payload;
    unsigned payload_len;
};

#define TEST1_BUF_LEN      (4 + 8 + 5 + 9 + 1 + 16)
#define TEST1_TOKEN_LEN    8
#define TEST1_OP1_LEN      4
#define TEST1_OP2_LEN      8
#define TEST1_NUM_OPS      2
#define TEST1_PAYLOAD_LEN  16

int test1_add_op_ret[TEST1_NUM_OPS] = {0, 0};
char test1_buf[TEST1_BUF_LEN] =
{
    /* header:         */ 0x58, 0x44, 0x12, 0x34,
    /* token:          */ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    /* option1:        */ 0x04, 0xa1, 0xa2, 0xa3, 0xa4,
    /* option2:        */ 0x18, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8,
    /* payload marker: */ 0xff,
    /* payload:        */ 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf
};
char test1_token[TEST1_TOKEN_LEN] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
char test1_op1_val[TEST1_OP1_LEN] = {0xa1, 0xa2, 0xa3, 0xa4};
char test1_op2_val[TEST1_OP2_LEN] = {0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8};
struct test_op test1_ops[TEST1_NUM_OPS] =
{
    [0] =
    {
        .num = 0,
        .len = TEST1_OP1_LEN,
        .val = test1_op1_val
    },
    [1] =
    {
        .num = 1,
        .len = TEST1_OP2_LEN,
        .val = test1_op2_val
    }
};
char test1_payload[TEST1_PAYLOAD_LEN] = {0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf};

struct test_data test1_data =
{
    .parse_desc = "test  1: parse CoAP message with token, with options, with payload",
    .format_desc = "test 27: format CoAP message with token, with options, with payload",
    .parse_ret = 0,
    .set_type_ret = 0,
    .set_code_ret = 0,
    .set_msg_id_ret = 0,
    .set_token_ret = 0,
    .add_op_ret = test1_add_op_ret,
    .set_payload_ret = 0,
    .format_ret = TEST1_BUF_LEN,
    .buf = test1_buf,
    .buf_len = TEST1_BUF_LEN,
    .ver = COAP_MSG_VER,
    .type = COAP_MSG_NON,
    .code_class = 0x2,
    .code_detail = 0x4,
    .msg_id = 0x1234,
    .token = test1_token,
    .token_len = TEST1_TOKEN_LEN,
    .ops = test1_ops,
    .num_ops = TEST1_NUM_OPS,
    .payload = test1_payload,
    .payload_len = TEST1_PAYLOAD_LEN
};

#define TEST2_BUF_LEN      (4 + 5 + 9 + 1 + 16)
#define TEST2_OP1_LEN      4
#define TEST2_OP2_LEN      8
#define TEST2_NUM_OPS      2
#define TEST2_PAYLOAD_LEN  16

int test2_add_op_ret[TEST2_NUM_OPS] = {0, 0};
char test2_buf[TEST2_BUF_LEN] =
{
    /* header:         */ 0x50, 0x44, 0x12, 0x34,
    /* option1:        */ 0x04, 0xa1, 0xa2, 0xa3, 0xa4,
    /* option2:        */ 0x18, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8,
    /* payload marker: */ 0xff,
    /* payload:        */ 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf
};
char test2_op1_val[TEST2_OP1_LEN] = {0xa1, 0xa2, 0xa3, 0xa4};
char test2_op2_val[TEST2_OP2_LEN] = {0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8};
struct test_op test2_ops[TEST2_NUM_OPS] =
{
    [0] =
    {
        .num = 0,
        .len = TEST2_OP1_LEN,
        .val = test2_op1_val
    },
    [1] =
    {
        .num = 1,
        .len = TEST2_OP2_LEN,
        .val = test2_op2_val
    }
};
char test2_payload[TEST2_PAYLOAD_LEN] = {0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf};

struct test_data test2_data =
{
    .parse_desc = "test  2: parse CoAP message with no token, with options, with payload",
    .format_desc = "test 28: format CoAP message with no token, with options, with payload",
    .parse_ret = 0,
    .set_type_ret = 0,
    .set_code_ret = 0,
    .set_msg_id_ret = 0,
    .set_token_ret = 0,
    .add_op_ret = test2_add_op_ret,
    .set_payload_ret = 0,
    .format_ret = TEST2_BUF_LEN,
    .buf = test2_buf,
    .buf_len = TEST2_BUF_LEN,
    .ver = COAP_MSG_VER,
    .type = COAP_MSG_NON,
    .code_class = 0x2,
    .code_detail = 0x4,
    .msg_id = 0x1234,
    .token = NULL,
    .token_len = 0,
    .ops = test1_ops,
    .num_ops = TEST2_NUM_OPS,
    .payload = test1_payload,
    .payload_len = TEST2_PAYLOAD_LEN
};

#define TEST3_BUF_LEN      (4 + 8 + 1 + 16)
#define TEST3_TOKEN_LEN    8
#define TEST3_PAYLOAD_LEN  16

char test3_buf[TEST3_BUF_LEN] =
{
    /* header:         */ 0x58, 0x44, 0x12, 0x34,
    /* token:          */ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    /* payload marker: */ 0xff,
    /* payload:        */ 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf
};
char test3_token[TEST3_TOKEN_LEN] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
char test3_payload[TEST3_PAYLOAD_LEN] = {0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf};

struct test_data test3_data =
{
    .parse_desc = "test  3: parse CoAP message with token, with no options, with payload",
    .format_desc = "test 29: format CoAP message with token, with no options, with payload",
    .parse_ret = 0,
    .set_type_ret = 0,
    .set_code_ret = 0,
    .set_msg_id_ret = 0,
    .set_token_ret = 0,
    .add_op_ret = NULL,
    .set_payload_ret = 0,
    .format_ret = TEST3_BUF_LEN,
    .buf = test3_buf,
    .buf_len = TEST3_BUF_LEN,
    .ver = COAP_MSG_VER,
    .type = COAP_MSG_NON,
    .code_class = 0x2,
    .code_detail = 0x4,
    .msg_id = 0x1234,
    .token = test3_token,
    .token_len = TEST3_TOKEN_LEN,
    .ops = NULL,
    .num_ops = 0,
    .payload = test3_payload,
    .payload_len = TEST3_PAYLOAD_LEN
};

#define TEST4_BUF_LEN    (4 + 8 + 5 + 9)
#define TEST4_TOKEN_LEN  8
#define TEST4_OP1_LEN    4
#define TEST4_OP2_LEN    8
#define TEST4_NUM_OPS    2

int test4_add_op_ret[TEST4_NUM_OPS] = {0, 0};
char test4_buf[TEST4_BUF_LEN] =
{
    /* header:  */ 0x58, 0x44, 0x12, 0x34,
    /* token:   */ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    /* option1: */ 0x04, 0xa1, 0xa2, 0xa3, 0xa4,
    /* option2: */ 0x18, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8
};
char test4_token[TEST4_TOKEN_LEN] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
char test4_op1_val[TEST4_OP1_LEN] = {0xa1, 0xa2, 0xa3, 0xa4};
char test4_op2_val[TEST4_OP2_LEN] = {0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8};
struct test_op test4_ops[TEST4_NUM_OPS] =
{
    [0] =
    {
        .num = 0,
        .len = TEST4_OP1_LEN,
        .val = test4_op1_val
    },
    [1] =
    {
        .num = 1,
        .len = TEST4_OP2_LEN,
        .val = test4_op2_val
    }
};

struct test_data test4_data =
{
    .parse_desc = "test  4: parse CoAP message with token, with options, with no payload",
    .format_desc = "test 30: format CoAP message with token, with options, with no payload",
    .parse_ret = 0,
    .set_type_ret = 0,
    .set_code_ret = 0,
    .set_msg_id_ret = 0,
    .set_token_ret = 0,
    .add_op_ret = test4_add_op_ret,
    .set_payload_ret = 0,
    .format_ret = TEST4_BUF_LEN,
    .buf = test4_buf,
    .buf_len = TEST4_BUF_LEN,
    .ver = COAP_MSG_VER,
    .type = COAP_MSG_NON,
    .code_class = 0x2,
    .code_detail = 0x4,
    .msg_id = 0x1234,
    .token = test4_token,
    .token_len = TEST4_TOKEN_LEN,
    .ops = test4_ops,
    .num_ops = TEST4_NUM_OPS,
    .payload = NULL,
    .payload_len = 0
};

#define TEST5_BUF_LEN      (4 + 1 + 16)
#define TEST5_PAYLOAD_LEN  16

char test5_buf[TEST5_BUF_LEN] =
{
    /* header:         */ 0x50, 0x44, 0x12, 0x34,
    /* payload marker: */ 0xff,
    /* payload:        */ 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf
};
char test5_payload[TEST5_PAYLOAD_LEN] = {0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf};

struct test_data test5_data =
{
    .parse_desc = "test  5: parse CoAP message with no token, with no options, with payload",
    .format_desc = "test 31: format CoAP message with no token, with no options, with payload",
    .parse_ret = 0,
    .set_type_ret = 0,
    .set_code_ret = 0,
    .set_msg_id_ret = 0,
    .set_token_ret = 0,
    .add_op_ret = NULL,
    .set_payload_ret = 0,
    .format_ret = TEST5_BUF_LEN,
    .buf = test5_buf,
    .buf_len = TEST5_BUF_LEN,
    .ver = COAP_MSG_VER,
    .type = COAP_MSG_NON,
    .code_class = 0x2,
    .code_detail = 0x4,
    .msg_id = 0x1234,
    .token = NULL,
    .token_len = 0,
    .ops = NULL,
    .num_ops = 0,
    .payload = test5_payload,
    .payload_len = TEST5_PAYLOAD_LEN
};

#define TEST6_BUF_LEN  (4 + 5 + 9)
#define TEST6_OP1_LEN  4
#define TEST6_OP2_LEN  8
#define TEST6_NUM_OPS  2

int test6_add_op_ret[TEST6_NUM_OPS] = {0, 0};
char test6_buf[TEST6_BUF_LEN] =
{
    /* header:  */ 0x50, 0x44, 0x12, 0x34,
    /* option1: */ 0x04, 0xa1, 0xa2, 0xa3, 0xa4,
    /* option2: */ 0x18, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8
};
char test6_op1_val[TEST6_OP1_LEN] = {0xa1, 0xa2, 0xa3, 0xa4};
char test6_op2_val[TEST6_OP2_LEN] = {0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8};
struct test_op test6_ops[TEST6_NUM_OPS] =
{
    [0] =
    {
        .num = 0,
        .len = TEST6_OP1_LEN,
        .val = test6_op1_val
    },
    [1] =
    {
        .num = 1,
        .len = TEST6_OP2_LEN,
        .val = test6_op2_val
    }
};

struct test_data test6_data =
{
    .parse_desc = "test  6: parse CoAP message with no token, with options, with no payload",
    .format_desc = "test 32: format CoAP message with no token, with options, with no payload",
    .parse_ret = 0,
    .set_type_ret = 0,
    .set_code_ret = 0,
    .set_msg_id_ret = 0,
    .set_token_ret = 0,
    .add_op_ret = test6_add_op_ret,
    .set_payload_ret = 0,
    .format_ret = TEST6_BUF_LEN,
    .buf = test6_buf,
    .buf_len = TEST6_BUF_LEN,
    .ver = COAP_MSG_VER,
    .type = COAP_MSG_NON,
    .code_class = 0x2,
    .code_detail = 0x4,
    .msg_id = 0x1234,
    .token = NULL,
    .token_len = 0,
    .ops = test6_ops,
    .num_ops = TEST6_NUM_OPS,
    .payload = NULL,
    .payload_len = 0
};

#define TEST7_BUF_LEN    (4 + 8)
#define TEST7_TOKEN_LEN  8

char test7_buf[TEST7_BUF_LEN] =
{
    /* header: */ 0x58, 0x44, 0x12, 0x34,
    /* token:  */ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08
};
char test7_token[TEST7_TOKEN_LEN] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};

struct test_data test7_data =
{
    .parse_desc = "test  7: parse CoAP message with token, with no options, with no payload",
    .format_desc = "test 33: format CoAP message with token, with no options, with no payload",
    .parse_ret = 0,
    .set_type_ret = 0,
    .set_code_ret = 0,
    .set_msg_id_ret = 0,
    .set_token_ret = 0,
    .add_op_ret = NULL,
    .set_payload_ret = 0,
    .format_ret = TEST7_BUF_LEN,
    .buf = test7_buf,
    .buf_len = TEST7_BUF_LEN,
    .ver = COAP_MSG_VER,
    .type = COAP_MSG_NON,
    .code_class = 0x2,
    .code_detail = 0x4,
    .msg_id = 0x1234,
    .token = test7_token,
    .token_len = TEST7_TOKEN_LEN,
    .ops = NULL,
    .num_ops = 0,
    .payload = NULL,
    .payload_len = 0
};

#define TEST8_BUF_LEN  4

char test8_buf[TEST8_BUF_LEN] =
{
    /* header: */ 0x50, 0x44, 0x12, 0x34,
};

struct test_data test8_data =
{
    .parse_desc = "test  8: parse CoAP message with no token, with no options, with no payload",
    .format_desc = "test 34: format CoAP message with no token, with no options, with no payload",
    .parse_ret = 0,
    .set_type_ret = 0,
    .set_code_ret = 0,
    .set_msg_id_ret = 0,
    .set_token_ret = 0,
    .add_op_ret = NULL,
    .set_payload_ret = 0,
    .format_ret = TEST8_BUF_LEN,
    .buf = test8_buf,
    .buf_len = TEST8_BUF_LEN,
    .ver = COAP_MSG_VER,
    .type = COAP_MSG_NON,
    .code_class = 0x2,
    .code_detail = 0x4,
    .msg_id = 0x1234,
    .token = NULL,
    .token_len = 0,
    .ops = NULL,
    .num_ops = 0,
    .payload = NULL,
    .payload_len = 0
};

#define TEST9_BUF_LEN      (4 + 8 + 5 + 10 + 1 + 16)
#define TEST9_TOKEN_LEN    8
#define TEST9_OP1_LEN      4
#define TEST9_OP2_LEN      8
#define TEST9_NUM_OPS      2
#define TEST9_PAYLOAD_LEN  16

int test9_add_op_ret[TEST9_NUM_OPS] = {0, 0};
char test9_buf[TEST9_BUF_LEN] =
{
    /* header:         */ 0x58, 0x44, 0x12, 0x34,
    /* token:          */ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    /* option1:        */ 0x04, 0xa1, 0xa2, 0xa3, 0xa4,
    /* option2:        */ 0xd8, 0x01, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8,
    /* payload marker: */ 0xff,
    /* payload:        */ 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf
};
char test9_token[TEST9_TOKEN_LEN] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
char test9_op1_val[TEST9_OP1_LEN] = {0xa1, 0xa2, 0xa3, 0xa4};
char test9_op2_val[TEST9_OP2_LEN] = {0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8};
struct test_op test9_ops[TEST9_NUM_OPS] =
{
    [0] =
    {
        .num = 0,
        .len = TEST9_OP1_LEN,
        .val = test9_op1_val
    },
    [1] =
    {
        .num = 13 + 0x01,
        .len = TEST9_OP2_LEN,
        .val = test9_op2_val
    }
};
char test9_payload[TEST9_PAYLOAD_LEN] = {0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf};

struct test_data test9_data =
{
    .parse_desc = "test  9: parse CoAP message with option delta extended by 1-byte",
    .format_desc = "test 35: format CoAP message with option delta extended by 1-byte",
    .parse_ret = 0,
    .set_type_ret = 0,
    .set_code_ret = 0,
    .set_msg_id_ret = 0,
    .set_token_ret = 0,
    .add_op_ret = test9_add_op_ret,
    .set_payload_ret = 0,
    .format_ret = TEST9_BUF_LEN,
    .buf = test9_buf,
    .buf_len = TEST9_BUF_LEN,
    .ver = COAP_MSG_VER,
    .type = COAP_MSG_NON,
    .code_class = 0x2,
    .code_detail = 0x4,
    .msg_id = 0x1234,
    .token = test9_token,
    .token_len = TEST9_TOKEN_LEN,
    .ops = test9_ops,
    .num_ops = TEST9_NUM_OPS,
    .payload = test9_payload,
    .payload_len = TEST9_PAYLOAD_LEN
};

#define TEST10_BUF_LEN      (4 + 8 + 5 + 11 + 1 + 16)
#define TEST10_TOKEN_LEN    8
#define TEST10_OP1_LEN      4
#define TEST10_OP2_LEN      8
#define TEST10_NUM_OPS      2
#define TEST10_PAYLOAD_LEN  16

int test10_add_op_ret[TEST10_NUM_OPS] = {0, 0};
char test10_buf[TEST10_BUF_LEN] =
{
    /* header:         */ 0x58, 0x44, 0x12, 0x34,
    /* token:          */ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    /* option1:        */ 0x04, 0xa1, 0xa2, 0xa3, 0xa4,
    /* option2:        */ 0xe8, 0x01, 0x02, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8,
    /* payload marker: */ 0xff,
    /* payload:        */ 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf
};
char test10_token[TEST10_TOKEN_LEN] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
char test10_op1_val[TEST10_OP1_LEN] = {0xa1, 0xa2, 0xa3, 0xa4};
char test10_op2_val[TEST10_OP2_LEN] = {0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8};
struct test_op test10_ops[TEST10_NUM_OPS] =
{
    [0] =
    {
        .num = 0,
        .len = TEST10_OP1_LEN,
        .val = test10_op1_val
    },
    [1] =
    {
        .num = 269 + 0x0102,
        .len = TEST10_OP2_LEN,
        .val = test10_op2_val
    }
};
char test10_payload[TEST10_PAYLOAD_LEN] = {0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf};

struct test_data test10_data =
{
    .parse_desc = "test 10: parse CoAP message with option delta extended by 2-bytes",
    .format_desc = "test 36: format CoAP message with option delta extended by 2-bytes",
    .parse_ret = 0,
    .set_type_ret = 0,
    .set_code_ret = 0,
    .set_msg_id_ret = 0,
    .set_token_ret = 0,
    .add_op_ret = test10_add_op_ret,
    .set_payload_ret = 0,
    .format_ret = TEST10_BUF_LEN,
    .buf = test10_buf,
    .buf_len = TEST10_BUF_LEN,
    .ver = COAP_MSG_VER,
    .type = COAP_MSG_NON,
    .code_class = 0x2,
    .code_detail = 0x4,
    .msg_id = 0x1234,
    .token = test10_token,
    .token_len = TEST10_TOKEN_LEN,
    .ops = test10_ops,
    .num_ops = TEST10_NUM_OPS,
    .payload = test10_payload,
    .payload_len = TEST10_PAYLOAD_LEN
};

#define TEST11_BUF_LEN      (4 + 8 + 5 + 16 + 1 + 16)
#define TEST11_TOKEN_LEN    8
#define TEST11_OP1_LEN      4
#define TEST11_OP2_LEN      (13 + 0x01)
#define TEST11_NUM_OPS      2
#define TEST11_PAYLOAD_LEN  16

int test11_add_op_ret[TEST11_NUM_OPS] = {0, 0};
char test11_buf[TEST11_BUF_LEN] =
{
    /* header:         */ 0x58, 0x44, 0x12, 0x34,
    /* token:          */ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    /* option1:        */ 0x04, 0xa1, 0xa2, 0xa3, 0xa4,
    /* option2:        */ 0x1d, 0x01, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe,
    /* payload marker: */ 0xff,
    /* payload:        */ 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf
};
char test11_token[TEST11_TOKEN_LEN] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
char test11_op1_val[TEST11_OP1_LEN] = {0xa1, 0xa2, 0xa3, 0xa4};
char test11_op2_val[TEST11_OP2_LEN] = {0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe};
struct test_op test11_ops[TEST11_NUM_OPS] =
{
    [0] =
    {
        .num = 0,
        .len = TEST11_OP1_LEN,
        .val = test11_op1_val
    },
    [1] =
    {
        .num = 1,
        .len = TEST11_OP2_LEN,
        .val = test11_op2_val
    }
};
char test11_payload[TEST11_PAYLOAD_LEN] = {0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf};

struct test_data test11_data =
{
    .parse_desc = "test 11: parse CoAP message with option length extended by 1-byte",
    .format_desc = "test 37: format CoAP message with option length extended by 1-byte",
    .parse_ret = 0,
    .set_type_ret = 0,
    .set_code_ret = 0,
    .set_msg_id_ret = 0,
    .set_token_ret = 0,
    .add_op_ret = test11_add_op_ret,
    .set_payload_ret = 0,
    .format_ret = TEST11_BUF_LEN,
    .buf = test11_buf,
    .buf_len = TEST11_BUF_LEN,
    .ver = COAP_MSG_VER,
    .type = COAP_MSG_NON,
    .code_class = 0x2,
    .code_detail = 0x4,
    .msg_id = 0x1234,
    .token = test11_token,
    .token_len = TEST11_TOKEN_LEN,
    .ops = test11_ops,
    .num_ops = TEST11_NUM_OPS,
    .payload = test11_payload,
    .payload_len = TEST11_PAYLOAD_LEN
};

#define TEST12_BUF_LEN      (4 + 8 + 5 + 530 + 1 + 16)
#define TEST12_TOKEN_LEN    8
#define TEST12_OP1_LEN      4
#define TEST12_OP2_LEN      (269 + 0x0102)
#define TEST12_NUM_OPS      2
#define TEST12_PAYLOAD_LEN  16

int test12_add_op_ret[TEST12_NUM_OPS] = {0, 0};
char test12_buf[TEST12_BUF_LEN] =
{
    /* header:         */ 0x58, 0x44, 0x12, 0x34,
    /* token:          */ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    /* option1:        */ 0x04, 0xa1, 0xa2, 0xa3, 0xa4,
    /* option2:        */ 0x1e, 0x01, 0x02, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e,
    /* payload marker: */ 0xff,
    /* payload:        */ 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf
};
char test12_token[TEST12_TOKEN_LEN] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
char test12_op1_val[TEST12_OP1_LEN] = {0xa1, 0xa2, 0xa3, 0xa4};
char test12_op2_val[TEST12_OP2_LEN] = {0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e};
struct test_op test12_ops[TEST12_NUM_OPS] =
{
    [0] =
    {
        .num = 0,
        .len = TEST12_OP1_LEN,
        .val = test12_op1_val
    },
    [1] =
    {
        .num = 1,
        .len = TEST12_OP2_LEN,
        .val = test12_op2_val
    }
};
char test12_payload[TEST12_PAYLOAD_LEN] = {0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf};

struct test_data test12_data =
{
    .parse_desc = "test 12: parse CoAP message with option length extended by 2-bytes",
    .format_desc = "test 38: format CoAP message with option length extended by 2-bytes",
    .parse_ret = 0,
    .set_type_ret = 0,
    .set_code_ret = 0,
    .set_msg_id_ret = 0,
    .set_token_ret = 0,
    .add_op_ret = test12_add_op_ret,
    .set_payload_ret = 0,
    .format_ret = TEST12_BUF_LEN,
    .buf = test12_buf,
    .buf_len = TEST12_BUF_LEN,
    .ver = COAP_MSG_VER,
    .type = COAP_MSG_NON,
    .code_class = 0x2,
    .code_detail = 0x4,
    .msg_id = 0x1234,
    .token = test12_token,
    .token_len = TEST12_TOKEN_LEN,
    .ops = test12_ops,
    .num_ops = TEST12_NUM_OPS,
    .payload = test12_payload,
    .payload_len = TEST12_PAYLOAD_LEN
};

#define TEST13_BUF_LEN      (4 + 8 + 5 + 17 + 1 + 16)
#define TEST13_TOKEN_LEN    8
#define TEST13_OP1_LEN      4
#define TEST13_OP2_LEN      (13 + 0x01)
#define TEST13_NUM_OPS      2
#define TEST13_PAYLOAD_LEN  16

int test13_add_op_ret[TEST13_NUM_OPS] = {0, 0};
char test13_buf[TEST13_BUF_LEN] =
{
    /* header:         */ 0x58, 0x44, 0x12, 0x34,
    /* token:          */ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    /* option1:        */ 0x04, 0xa1, 0xa2, 0xa3, 0xa4,
    /* option2:        */ 0xdd, 0x02, 0x01, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe,
    /* payload marker: */ 0xff,
    /* payload:        */ 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf
};
char test13_token[TEST13_TOKEN_LEN] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
char test13_op1_val[TEST13_OP1_LEN] = {0xa1, 0xa2, 0xa3, 0xa4};
char test13_op2_val[TEST13_OP2_LEN] = {0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe};
struct test_op test13_ops[TEST13_NUM_OPS] =
{
    [0] =
    {
        .num = 0,
        .len = TEST13_OP1_LEN,
        .val = test13_op1_val
    },
    [1] =
    {
        .num = 13 + 0x02,
        .len = TEST13_OP2_LEN,
        .val = test13_op2_val
    }
};
char test13_payload[TEST13_PAYLOAD_LEN] = {0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf};

struct test_data test13_data =
{
    .parse_desc = "test 13: parse CoAP message with option delta extended by 1-byte and option length extended by 1-byte",
    .format_desc = "test 39: format CoAP message with option delta extended by 1-byte and option length extended by 1-byte",
    .parse_ret = 0,
    .set_type_ret = 0,
    .set_code_ret = 0,
    .set_msg_id_ret = 0,
    .set_token_ret = 0,
    .add_op_ret = test13_add_op_ret,
    .set_payload_ret = 0,
    .format_ret = TEST13_BUF_LEN,
    .buf = test13_buf,
    .buf_len = TEST13_BUF_LEN,
    .ver = COAP_MSG_VER,
    .type = COAP_MSG_NON,
    .code_class = 0x2,
    .code_detail = 0x4,
    .msg_id = 0x1234,
    .token = test13_token,
    .token_len = TEST13_TOKEN_LEN,
    .ops = test13_ops,
    .num_ops = TEST13_NUM_OPS,
    .payload = test13_payload,
    .payload_len = TEST13_PAYLOAD_LEN
};

#define TEST14_BUF_LEN      (4 + 8 + 5 + 18 + 1 + 16)
#define TEST14_TOKEN_LEN    8
#define TEST14_OP1_LEN      4
#define TEST14_OP2_LEN      (13 + 0x01)
#define TEST14_NUM_OPS      2
#define TEST14_PAYLOAD_LEN  16

int test14_add_op_ret[TEST14_NUM_OPS] = {0, 0};
char test14_buf[TEST14_BUF_LEN] =
{
    /* header:         */ 0x58, 0x44, 0x12, 0x34,
    /* token:          */ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    /* option1:        */ 0x04, 0xa1, 0xa2, 0xa3, 0xa4,
    /* option2:        */ 0xed, 0x02, 0x03, 0x01, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe,
    /* payload marker: */ 0xff,
    /* payload:        */ 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf
};
char test14_token[TEST14_TOKEN_LEN] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
char test14_op1_val[TEST14_OP1_LEN] = {0xa1, 0xa2, 0xa3, 0xa4};
char test14_op2_val[TEST14_OP2_LEN] = {0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe};
struct test_op test14_ops[TEST14_NUM_OPS] =
{
    [0] =
    {
        .num = 0,
        .len = TEST14_OP1_LEN,
        .val = test14_op1_val
    },
    [1] =
    {
        .num = 269 + 0x0203,
        .len = TEST14_OP2_LEN,
        .val = test14_op2_val
    }
};
char test14_payload[TEST14_PAYLOAD_LEN] = {0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf};

struct test_data test14_data =
{
    .parse_desc = "test 14: parse CoAP message with option delta extended by 2-bytes and option length extended by 1-byte",
    .format_desc = "test 40: format CoAP message with option delta extended by 2-bytes and option length extended by 1-byte",
    .parse_ret = 0,
    .set_type_ret = 0,
    .set_code_ret = 0,
    .set_msg_id_ret = 0,
    .set_token_ret = 0,
    .add_op_ret = test14_add_op_ret,
    .set_payload_ret = 0,
    .format_ret = TEST14_BUF_LEN,
    .buf = test14_buf,
    .buf_len = TEST14_BUF_LEN,
    .ver = COAP_MSG_VER,
    .type = COAP_MSG_NON,
    .code_class = 0x2,
    .code_detail = 0x4,
    .msg_id = 0x1234,
    .token = test14_token,
    .token_len = TEST14_TOKEN_LEN,
    .ops = test14_ops,
    .num_ops = TEST14_NUM_OPS,
    .payload = test14_payload,
    .payload_len = TEST14_PAYLOAD_LEN
};

#define TEST15_BUF_LEN      (4 + 8 + 5 + 531 + 1 + 16)
#define TEST15_TOKEN_LEN    8
#define TEST15_OP1_LEN      4
#define TEST15_OP2_LEN      (269 + 0x0102)
#define TEST15_NUM_OPS      2
#define TEST15_PAYLOAD_LEN  16

int test15_add_op_ret[TEST15_NUM_OPS] = {0, 0};
char test15_buf[TEST15_BUF_LEN] =
{
    /* header:         */ 0x58, 0x44, 0x12, 0x34,
    /* token:          */ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    /* option1:        */ 0x04, 0xa1, 0xa2, 0xa3, 0xa4,
    /* option2:        */ 0xde, 0x03, 0x01, 0x02, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e,
    /* payload marker: */ 0xff,
    /* payload:        */ 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf
};
char test15_token[TEST15_TOKEN_LEN] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
char test15_op1_val[TEST15_OP1_LEN] = {0xa1, 0xa2, 0xa3, 0xa4};
char test15_op2_val[TEST15_OP2_LEN] = {0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e};
struct test_op test15_ops[TEST15_NUM_OPS] =
{
    [0] =
    {
        .num = 0,
        .len = TEST15_OP1_LEN,
        .val = test15_op1_val
    },
    [1] =
    {
        .num = 13 + 0x03,
        .len = TEST15_OP2_LEN,
        .val = test15_op2_val
    }
};
char test15_payload[TEST15_PAYLOAD_LEN] = {0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf};

struct test_data test15_data =
{
    .parse_desc = "test 15: parse CoAP message with option delta extended by 1-byte and option length extended by 2-bytes",
    .format_desc = "test 41: format CoAP message with option delta extended by 1-byte and option length extended by 2-bytes",
    .parse_ret = 0,
    .set_type_ret = 0,
    .set_code_ret = 0,
    .set_msg_id_ret = 0,
    .set_token_ret = 0,
    .add_op_ret = test15_add_op_ret,
    .set_payload_ret = 0,
    .format_ret = TEST15_BUF_LEN,
    .buf = test15_buf,
    .buf_len = TEST15_BUF_LEN,
    .ver = COAP_MSG_VER,
    .type = COAP_MSG_NON,
    .code_class = 0x2,
    .code_detail = 0x4,
    .msg_id = 0x1234,
    .token = test15_token,
    .token_len = TEST15_TOKEN_LEN,
    .ops = test15_ops,
    .num_ops = TEST15_NUM_OPS,
    .payload = test15_payload,
    .payload_len = TEST15_PAYLOAD_LEN
};

#define TEST16_BUF_LEN      (4 + 8 + 5 + 532 + 1 + 16)
#define TEST16_TOKEN_LEN    8
#define TEST16_OP1_LEN      4
#define TEST16_OP2_LEN      (269 + 0x0102)
#define TEST16_NUM_OPS      2
#define TEST16_PAYLOAD_LEN  16

int test16_add_op_ret[TEST16_NUM_OPS] = {0, 0};
char test16_buf[TEST16_BUF_LEN] =
{
    /* header:         */ 0x58, 0x44, 0x12, 0x34,
    /* token:          */ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    /* option1:        */ 0x04, 0xa1, 0xa2, 0xa3, 0xa4,
    /* option2:        */ 0xee, 0x03, 0x04, 0x01, 0x02, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e,
    /* payload marker: */ 0xff,
    /* payload:        */ 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf
};
char test16_token[TEST16_TOKEN_LEN] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
char test16_op1_val[TEST16_OP1_LEN] = {0xa1, 0xa2, 0xa3, 0xa4};
char test16_op2_val[TEST16_OP2_LEN] = {0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e};
struct test_op test16_ops[TEST16_NUM_OPS] =
{
    [0] =
    {
        .num = 0,
        .len = TEST16_OP1_LEN,
        .val = test16_op1_val
    },
    [1] =
    {
        .num = 269 + 0x0304,
        .len = TEST16_OP2_LEN,
        .val = test16_op2_val
    }
};
char test16_payload[TEST16_PAYLOAD_LEN] = {0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf};

struct test_data test16_data =
{
    .parse_desc = "test 16: parse CoAP message with option delta extended by 2-bytes and option length extended by 2-bytes",
    .format_desc = "test 42: format CoAP message with option delta extended by 2-bytes and option length extended by 2-bytes",
    .parse_ret = 0,
    .set_type_ret = 0,
    .set_code_ret = 0,
    .set_msg_id_ret = 0,
    .set_token_ret = 0,
    .add_op_ret = test16_add_op_ret,
    .set_payload_ret = 0,
    .format_ret = TEST16_BUF_LEN,
    .buf = test16_buf,
    .buf_len = TEST16_BUF_LEN,
    .ver = COAP_MSG_VER,
    .type = COAP_MSG_NON,
    .code_class = 0x2,
    .code_detail = 0x4,
    .msg_id = 0x1234,
    .token = test16_token,
    .token_len = TEST16_TOKEN_LEN,
    .ops = test16_ops,
    .num_ops = TEST16_NUM_OPS,
    .payload = test16_payload,
    .payload_len = TEST16_PAYLOAD_LEN
};

#define TEST17_BUF_LEN  4

char test17_buf[TEST17_BUF_LEN] =
{
    /* header: */ 0x90, 0x44, 0x12, 0x34
};

struct test_data test17_data =
{
    .parse_desc = "test 17: parse CoAP message with invalid version",
    .format_desc = NULL,
    .parse_ret = -EINVAL,
    .set_type_ret = 0,
    .set_code_ret = 0,
    .set_msg_id_ret = 0,
    .set_token_ret = 0,
    .add_op_ret = NULL,
    .set_payload_ret = 0,
    .format_ret = 0,
    .buf = test17_buf,
    .buf_len = TEST17_BUF_LEN,
    .ver = 0,
    .type = 0,
    .code_class = 0,
    .code_detail = 0,
    .msg_id = 0,
    .token = NULL,
    .token_len = 0,
    .ops = NULL,
    .num_ops = 0,
    .payload = NULL,
    .payload_len = 0
};

#define TEST18_BUF_LEN  4

char test18_buf[TEST18_BUF_LEN] =
{
    /* header: */ 0x50, 0x00, 0x12, 0x34
};

struct test_data test18_data =
{
    .parse_desc = "test 18: parse empty non-confirmable CoAP message",
    .format_desc = "test 43: format empty non-confirmable CoAP message",
    .parse_ret = -EBADMSG,
    .set_type_ret = 0,
    .set_code_ret = 0,
    .set_msg_id_ret = 0,
    .set_token_ret = 0,
    .add_op_ret = NULL,
    .set_payload_ret = 0,
    .format_ret = -EBADMSG,
    .buf = test18_buf,
    .buf_len = TEST18_BUF_LEN,
    .ver = COAP_MSG_VER,
    .type = COAP_MSG_NON,
    .code_class = 0,
    .code_detail = 0,
    .msg_id = 0x1234,
    .token = NULL,
    .token_len = 0,
    .ops = NULL,
    .num_ops = 0,
    .payload = NULL,
    .payload_len = 0
};

#define TEST19_BUF_LEN  4

char test19_buf[TEST19_BUF_LEN] =
{
    /* header: */ 0x70, 0x44, 0x12, 0x34
};

struct test_data test19_data =
{
    .parse_desc = "test 19: parse non-empty reset CoAP message",
    .format_desc = "test 44: format non-empty reset CoAP message",
    .parse_ret = -EBADMSG,
    .set_type_ret = 0,
    .set_code_ret = 0,
    .set_msg_id_ret = 0,
    .set_token_ret = 0,
    .add_op_ret = NULL,
    .set_payload_ret = 0,
    .format_ret = -EBADMSG,
    .buf = test19_buf,
    .buf_len = TEST19_BUF_LEN,
    .ver = COAP_MSG_VER,
    .type = COAP_MSG_RST,
    .code_class = 0x2,
    .code_detail = 0x4,
    .msg_id = 0x1234,
    .token = NULL,
    .token_len = 0,
    .ops = NULL,
    .num_ops = 0,
    .payload = NULL,
    .payload_len = 0
};

#define TEST20_BUF_LEN    (4 + 9)
#define TEST20_TOKEN_LEN  9

char test20_buf[TEST20_BUF_LEN] =
{
    /* header: */ 0x59, 0x44, 0x12, 0x34,
    /* token:  */ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09
};
char test20_token[TEST20_TOKEN_LEN] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09};

struct test_data test20_data =
{
    .parse_desc = "test 20: parse CoAP message with invalid token length (9)",
    .format_desc = "test 45: format CoAP message with invalid token length (9)",
    .parse_ret = -EBADMSG,
    .set_type_ret = 0,
    .set_code_ret = 0,
    .set_msg_id_ret = 0,
    .set_token_ret = -EINVAL,
    .add_op_ret = NULL,
    .set_payload_ret = 0,
    .format_ret = 0,
    .buf = test20_buf,
    .buf_len = TEST20_BUF_LEN,
    .ver = COAP_MSG_VER,
    .type = COAP_MSG_NON,
    .code_class = 0x2,
    .code_detail = 0x4,
    .msg_id = 0x1234,
    .token = test20_token,
    .token_len = TEST20_TOKEN_LEN,
    .ops = NULL,
    .num_ops = 0,
    .payload = NULL,
    .payload_len = 0
};

#define TEST21_BUF_LEN    (4 + 15)
#define TEST21_TOKEN_LEN  15

char test21_buf[TEST21_BUF_LEN] =
{
    /* header: */ 0x5f, 0x44, 0x12, 0x34,
    /* token:  */ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
};
char test21_token[TEST21_TOKEN_LEN] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f};

struct test_data test21_data =
{
    .parse_desc = "test 21: parse CoAP message with invalid token length (15)",
    .format_desc = "test 46: format CoAP message with invalid token length (15)",
    .parse_ret = -EBADMSG,
    .set_type_ret = 0,
    .set_code_ret = 0,
    .set_msg_id_ret = 0,
    .set_token_ret = -EINVAL,
    .add_op_ret = NULL,
    .set_payload_ret = 0,
    .format_ret = 0,
    .buf = test21_buf,
    .buf_len = TEST21_BUF_LEN,
    .ver = 0,
    .type = 0,
    .code_class = 0,
    .code_detail = 0,
    .msg_id = 0,
    .token = test21_token,
    .token_len = TEST21_TOKEN_LEN,
    .ops = NULL,
    .num_ops = 0,
    .payload = NULL,
    .payload_len = 0
};

#define TEST22_BUF_LEN    (4 + 8)
#define TEST22_TOKEN_LEN  8

char test22_buf[TEST22_BUF_LEN] =
{
    /* header: */ 0x58, 0x00, 0x12, 0x34,
    /* token:  */ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08
};
char test22_token[TEST22_TOKEN_LEN] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};

struct test_data test22_data =
{
    .parse_desc = "test 22: parse empty CoAP message with non-zero token length",
    .format_desc = "test 47: format empty CoAP message with non-zero token length",
    .parse_ret = -EBADMSG,
    .set_type_ret = 0,
    .set_code_ret = 0,
    .set_msg_id_ret = 0,
    .set_token_ret = 0,
    .add_op_ret = NULL,
    .set_payload_ret = 0,
    .format_ret = -EBADMSG,
    .buf = test22_buf,
    .buf_len = TEST22_BUF_LEN,
    .ver = COAP_MSG_VER,
    .type = COAP_MSG_CON,
    .code_class = 0,
    .code_detail = 0,
    .msg_id = 0x1234,
    .token = test22_token,
    .token_len = TEST22_TOKEN_LEN,
    .ops = NULL,
    .num_ops = 0,
    .payload = NULL,
    .payload_len = 0
};

#define TEST23_BUF_LEN      (4 + 1 + 16)
#define TEST23_PAYLOAD_LEN  16

char test23_buf[TEST23_BUF_LEN] =
{
    /* header:         */ 0x50, 0x00, 0x12, 0x34,
    /* payload marker: */ 0xff,
    /* payload:        */ 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf
};
char test23_payload[TEST23_PAYLOAD_LEN] = {0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf};

struct test_data test23_data =
{
    .parse_desc = "test 23: parse empty CoAP message with payload",
    .format_desc = "test 48: format empty CoAP message with payload",
    .parse_ret = -EBADMSG,
    .set_type_ret = 0,
    .set_code_ret = 0,
    .set_msg_id_ret = 0,
    .set_token_ret = 0,
    .add_op_ret = NULL,
    .set_payload_ret = 0,
    .format_ret = -EBADMSG,
    .buf = test23_buf,
    .buf_len = TEST23_BUF_LEN,
    .ver = COAP_MSG_VER,
    .type = COAP_MSG_CON,
    .code_class = 0,
    .code_detail = 0,
    .msg_id = 0X3412,
    .token = NULL,
    .token_len = 0,
    .ops = NULL,
    .num_ops = 0,
    .payload = test23_payload,
    .payload_len = TEST23_PAYLOAD_LEN
};

#define TEST24_BUF_LEN  (4 + 5 + 9)

char test24_buf[TEST24_BUF_LEN] =
{
    /* header:  */ 0x50, 0x44, 0x12, 0x34,
    /* option1: */ 0x04, 0xa1, 0xa2, 0xa3, 0xa4,
    /* option2: */ 0xf8, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8
};

struct test_data test24_data =
{
    .parse_desc = "test 24: parse CoAP message with invalid option delta",
    .format_desc = NULL,
    .parse_ret = -EBADMSG,
    .set_type_ret = 0,
    .set_code_ret = 0,
    .set_msg_id_ret = 0,
    .set_token_ret = 0,
    .add_op_ret = 0,
    .set_payload_ret = 0,
    .format_ret = 0,
    .buf = test24_buf,
    .buf_len = TEST24_BUF_LEN,
    .ver = 0,
    .type = 0,
    .code_class = 0,
    .code_detail = 0,
    .msg_id = 0,
    .token = NULL,
    .token_len = 0,
    .ops = NULL,
    .num_ops = 0,
    .payload = NULL,
    .payload_len = 0
};

#define TEST25_BUF_LEN  (4 + 5 + 16)

char test25_buf[TEST25_BUF_LEN] =
{
    /* header:  */ 0x50, 0x44, 0x12, 0x34,
    /* option1: */ 0x04, 0xa1, 0xa2, 0xa3, 0xa4,
    /* option2: */ 0x1f, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf
};

struct test_data test25_data =
{
    .parse_desc = "test 25: parse CoAP message with invalid option length",
    .format_desc = NULL,
    .parse_ret = -EBADMSG,
    .set_type_ret = 0,
    .set_code_ret = 0,
    .set_msg_id_ret = 0,
    .set_token_ret = 0,
    .add_op_ret = NULL,
    .set_payload_ret = 0,
    .format_ret = 0,
    .buf = test25_buf,
    .buf_len = TEST25_BUF_LEN,
    .ver = 0,
    .type = 0,
    .code_class = 0,
    .code_detail = 0,
    .msg_id = 0,
    .token = NULL,
    .token_len = 0,
    .ops = NULL,
    .num_ops = 0,
    .payload = NULL,
    .payload_len = 0
};

#define TEST26_BUF_LEN  5

char test26_buf[TEST26_BUF_LEN] =
{
    /* header:         */ 0x50, 0x44, 0x12, 0x34,
    /* payload marker: */ 0xff
};

struct test_data test26_data =
{
    .parse_desc = "test 26: parse CoAP message with payload marker but no payload",
    .format_desc = NULL,
    .parse_ret = -EBADMSG,
    .set_type_ret = 0,
    .set_code_ret = 0,
    .set_msg_id_ret = 0,
    .set_token_ret = 0,
    .add_op_ret = NULL,
    .set_payload_ret = 0,
    .format_ret = 0,
    .buf = test26_buf,
    .buf_len = TEST26_BUF_LEN,
    .ver = 0,
    .type = 0,
    .code_class = 0,
    .code_detail = 0,
    .msg_id = 0,
    .token = NULL,
    .token_len = 0,
    .ops = NULL,
    .num_ops = 0,
    .payload = NULL,
    .payload_len = 0
};

#define TEST27_BUF_LEN  4

char test27_buf[TEST27_BUF_LEN] =
{
    /* header: */ 0x50, 0x44, 0x12, 0x34
};

struct test_data test27_data =
{
    .parse_desc = "test 49: parse valid type and message ID",
    .format_desc = NULL,
    .parse_ret = 0,
    .set_type_ret = 0,
    .set_code_ret = 0,
    .set_msg_id_ret = 0,
    .set_token_ret = 0,
    .add_op_ret = NULL,
    .set_payload_ret = 0,
    .format_ret = 0,
    .buf = test27_buf,
    .buf_len = TEST27_BUF_LEN,
    .ver = 0,
    .type = COAP_MSG_NON,
    .code_class = 0,
    .code_detail = 0,
    .msg_id = 0x1234,
    .token = NULL,
    .token_len = 0,
    .ops = NULL,
    .num_ops = 0,
    .payload = NULL,
    .payload_len = 0
};

#define TEST28_BUF_LEN  3

char test28_buf[TEST28_BUF_LEN] =
{
    /* header: */ 0x50, 0x44, 0x12
};

struct test_data test28_data =
{
    .parse_desc = "test 50: parse invalid type and message ID",
    .format_desc = NULL,
    .parse_ret = -EBADMSG,
    .set_type_ret = 0,
    .set_code_ret = 0,
    .set_msg_id_ret = 0,
    .set_token_ret = 0,
    .add_op_ret = NULL,
    .set_payload_ret = 0,
    .format_ret = 0,
    .buf = test28_buf,
    .buf_len = TEST28_BUF_LEN,
    .ver = 0,
    .type = 0,
    .code_class = 0,
    .code_detail = 0,
    .msg_id = 0,
    .token = NULL,
    .token_len = 0,
    .ops = NULL,
    .num_ops = 0,
    .payload = NULL,
    .payload_len = 0
};

harness_result test_parse(harness_data data)
{
    struct test_data *test_data = (struct test_data *)data;
    harness_result result = PASS;
    coap_msg_op_t *op = NULL;
    coap_msg_t msg = {0};
    unsigned i = 0;
    int ret = 0;

    printf("%s\n", test_data->parse_desc);

    coap_msg_create(&msg);
    ret = coap_msg_parse(&msg, test_data->buf, test_data->buf_len);
    if (ret != test_data->parse_ret)
    {
        result = FAIL;
    }
    if (test_data->parse_ret != 0)
    {
        coap_msg_destroy(&msg);
        return result;
    }
    print_coap_msg(&msg);
    if (msg.ver != test_data->ver)
    {
        result = FAIL;
    }
    if (msg.type != test_data->type)
    {
        result = FAIL;
    }
    if (msg.token_len != test_data->token_len)
    {
        result = FAIL;
    }
    if (msg.code_class != test_data->code_class)
    {
        result = FAIL;
    }
    if (msg.code_detail != test_data->code_detail)
    {
        result = FAIL;
    }
    if (msg.msg_id != test_data->msg_id)
    {
        result = FAIL;
    }
    if (memcmp(msg.token, test_data->token, test_data->token_len) != 0)
    {
        result = FAIL;
    }
    op = coap_msg_op_list_get_first(&msg.op_list);
    for (i = 0; i < test_data->num_ops; i++)
    {
        if (op == NULL)
        {
            result = FAIL;
            break;
        }
        if (coap_msg_op_get_num(op) != test_data->ops[i].num)
        {
            result = FAIL;
        }
        if (coap_msg_op_get_len(op) != test_data->ops[i].len)
        {
            result = FAIL;
        }
        if (memcmp(coap_msg_op_get_val(op), test_data->ops[i].val, test_data->ops[0].len) != 0)
        {
            result = FAIL;
        }
        op = coap_msg_op_get_next(op);
    }
    if (op != NULL)
    {
        result = FAIL;
    }
    if (test_data->payload != NULL)
    {
        if ((msg.payload == NULL)
         || (memcmp(msg.payload, test_data->payload, test_data->payload_len) != 0))
        {
            result = FAIL;
        }
    }
    else
    {
        if (msg.payload != NULL)
        {
            result = FAIL;
        }
    }
    if (msg.payload_len != test_data->payload_len)
    {
        result = FAIL;
    }
    coap_msg_destroy(&msg);
    return result;
}

harness_result test_format(harness_data data)
{
    struct test_data *test_data = (struct test_data *)data;
    harness_result result = PASS;
    coap_msg_t msg = {0};
    unsigned i = 0;
    char tmp[test_data->buf_len];
    int ret = 0;

    printf("%s\n", test_data->format_desc);

    coap_msg_create(&msg);
    ret = coap_msg_set_type(&msg, test_data->type);
    if (ret != test_data->set_type_ret)
    {
        result = FAIL;
    }
    if (test_data->set_type_ret != 0)
    {
        coap_msg_destroy(&msg);
        return result;
    }
    ret = coap_msg_set_code(&msg, test_data->code_class, test_data->code_detail);
    if (ret != test_data->set_code_ret)
    {
        result = FAIL;
    }
    if (test_data->set_code_ret != 0)
    {
        coap_msg_destroy(&msg);
        return result;
    }
    ret = coap_msg_set_msg_id(&msg, test_data->msg_id);
    if (ret != test_data->set_msg_id_ret)
    {
        result = FAIL;
    }
    if (test_data->set_msg_id_ret != 0)
    {
        coap_msg_destroy(&msg);
        return result;
    }
    if (test_data->token_len > 0)
    {
        ret = coap_msg_set_token(&msg, test_data->token, test_data->token_len);
        if (ret != test_data->set_token_ret)
        {
            result = FAIL;
        }
        if (test_data->set_token_ret != 0)
        {
            coap_msg_destroy(&msg);
            return result;
        }
    }
    for (i = 0; i < test_data->num_ops; i++)
    {
        ret = coap_msg_add_op(&msg, test_data->ops[i].num, test_data->ops[i].len, test_data->ops[i].val);
        if (ret != test_data->add_op_ret[i])
        {
            result = FAIL;
        }
        if (test_data->add_op_ret[i] != 0)
        {
            coap_msg_destroy(&msg);
            return result;
        }
    }
    if (test_data->payload_len > 0)
    {
        ret = coap_msg_set_payload(&msg, test_data->payload, test_data->payload_len);
        if (ret != test_data->set_payload_ret)
        {
            result = FAIL;
        }
        if (test_data->set_payload_ret != 0)
        {
            coap_msg_destroy(&msg);
            return result;
        }
    }
    ret = coap_msg_format(&msg, tmp, sizeof(tmp));
    if (ret != test_data->format_ret)
    {
        result = FAIL;
    }
    if (test_data->format_ret < 0)
    {
        coap_msg_destroy(&msg);
        return result;
    }
    if (memcmp(tmp, test_data->buf, test_data->buf_len) != 0)
    {
        result = FAIL;
    }
    print_buf(tmp, sizeof(tmp));
    coap_msg_destroy(&msg);
    return result;
}

harness_result test_parse_type_msg_id(harness_data data)
{
    struct test_data *test_data = (struct test_data *)data;
    harness_result result = PASS;
    unsigned msg_id = 0;
    unsigned type = 0;
    int ret = 0;

    printf("%s\n", test_data->parse_desc);

    ret = coap_msg_parse_type_msg_id(test_data->buf, test_data->buf_len, &type, &msg_id);
    if (ret != test_data->parse_ret)
    {
        result = FAIL;
    }
    if (test_data->parse_ret == 0)
    {
        if (type != test_data->type)
        {
            result = FAIL;
        }
        if (msg_id != test_data->msg_id)
        {
            result = FAIL;
        }
    }
    return result;
}

int main(void)
{
    harness_test tests[] =
    {
        {test_parse,             &test1_data},
        {test_parse,             &test2_data},
        {test_parse,             &test3_data},
        {test_parse,             &test4_data},
        {test_parse,             &test5_data},
        {test_parse,             &test6_data},
        {test_parse,             &test7_data},
        {test_parse,             &test8_data},
        {test_parse,             &test9_data},
        {test_parse,             &test10_data},
        {test_parse,             &test11_data},
        {test_parse,             &test12_data},
        {test_parse,             &test13_data},
        {test_parse,             &test14_data},
        {test_parse,             &test15_data},
        {test_parse,             &test16_data},
        {test_parse,             &test17_data},
        {test_parse,             &test18_data},
        {test_parse,             &test19_data},
        {test_parse,             &test20_data},
        {test_parse,             &test21_data},
        {test_parse,             &test22_data},
        {test_parse,             &test23_data},
        {test_parse,             &test24_data},
        {test_parse,             &test25_data},
        {test_parse,             &test26_data},
        {test_format,            &test1_data},
        {test_format,            &test2_data},
        {test_format,            &test3_data},
        {test_format,            &test4_data},
        {test_format,            &test5_data},
        {test_format,            &test6_data},
        {test_format,            &test7_data},
        {test_format,            &test8_data},
        {test_format,            &test9_data},
        {test_format,            &test10_data},
        {test_format,            &test11_data},
        {test_format,            &test12_data},
        {test_format,            &test13_data},
        {test_format,            &test14_data},
        {test_format,            &test15_data},
        {test_format,            &test16_data},
        {test_format,            &test18_data},
        {test_format,            &test19_data},
        {test_format,            &test20_data},
        {test_format,            &test21_data},
        {test_format,            &test22_data},
        {test_format,            &test23_data},
        {test_parse_type_msg_id, &test27_data},
        {test_parse_type_msg_id, &test28_data}
    };

    harness_run(tests, DIM(tests));

    return 0;
}
